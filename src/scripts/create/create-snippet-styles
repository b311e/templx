#!/usr/bin/env bash
# Create Style Snippet Script
# Usage: create-snippet-style <expanded-folder-path> <snippet-name> <style-id1>,<style-id2>,...
# Extracts specified styles from a template and saves them as a snippet file

set -euo pipefail

# Convert Windows path to Unix path if needed (for Git Bash on Windows)
normalize_path() {
    local path="$1"
    if [[ "$path" =~ ^[A-Za-z]:\\ ]]; then
        # Convert C:\path to /c/path format
        local drive_letter=$(echo "${path:0:1}" | tr '[:upper:]' '[:lower:]')
        local rest_of_path="${path:3}"
        rest_of_path="${rest_of_path//\\//}"
        echo "/$drive_letter/$rest_of_path"
    else
        echo "$path"
    fi
}

show_help() {
    echo "Usage: create-snippet-style <expanded-folder-path> <snippet-name> <style-id1>,<style-id2>,..."
    echo ""
    echo "Create a style snippet file from specific styles in an unpacked template"
    echo ""
    echo "Arguments:"
    echo "  expanded-folder-path - Path to expanded template folder (in/ or expanded/)"
    echo "  snippet-name         - Name for the snippet file (e.g., 'custom-headings')"
    echo "  style-ids            - Comma-separated list of style IDs to extract"
    echo ""
    echo "Output:"
    echo "  Snippet saved to <template-dir>/partials/styles/<snippet-name>.xml"
    echo ""
    echo "Examples:"
    echo "  create-snippet-style builds/jbc/workspace/jbcNormal/in mySnippet Heading1,Heading2,Title"
    echo "  create-snippet-style expanded/ custom-styles Normal,BodyText,Caption"
    exit 0
}

if [[ "${1:-}" == "help" || "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
    show_help
fi

if [ $# -lt 3 ]; then
    echo "Error: Missing required arguments"
    echo ""
    show_help
fi

# Normalize and validate the expanded folder path
EXPANDED_PATH="$(normalize_path "$1")"
SNIPPET_NAME="$2"
STYLE_IDS="$3"

# Check if expanded folder exists
if [ ! -d "$EXPANDED_PATH" ]; then
    echo "Error: Expanded folder not found: $EXPANDED_PATH"
    exit 1
fi

# Find styles.xml
STYLES_XML="$EXPANDED_PATH/word/styles.xml"
if [ ! -f "$STYLES_XML" ]; then
    echo "Error: styles.xml not found at: $STYLES_XML"
    exit 1
fi

# Determine the template directory (parent of in/ or expanded/)
TEMPLATE_DIR="$(dirname "$EXPANDED_PATH")"

# Create partials/styles directory if it doesn't exist
PARTIALS_DIR="$TEMPLATE_DIR/partials/styles"
mkdir -p "$PARTIALS_DIR"

# Convert snippet name to kebab-case for filename
# e.g., jbcNormalHeadings -> jbc-normal-headings
FILE_NAME=$(echo "$SNIPPET_NAME" | sed 's/\([a-z]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')

# Output file path
OUTPUT_FILE="$PARTIALS_DIR/${FILE_NAME}.xml"

# Convert comma-separated style IDs to array
IFS=',' read -ra STYLE_ID_ARRAY <<< "$STYLE_IDS"

# Trim whitespace from each style ID
for i in "${!STYLE_ID_ARRAY[@]}"; do
    STYLE_ID_ARRAY[$i]=$(echo "${STYLE_ID_ARRAY[$i]}" | xargs)
done

echo "Creating snippet: $SNIPPET_NAME"
echo "Source: $STYLES_XML"
echo "Style IDs: ${STYLE_ID_ARRAY[*]}"
echo "Output: $OUTPUT_FILE"

# Use Python to extract styles
python3 - "$STYLES_XML" "$OUTPUT_FILE" "$SNIPPET_NAME" "${STYLE_ID_ARRAY[@]}" << 'PYTHON_SCRIPT'
import sys
import xml.etree.ElementTree as ET

styles_xml_path = sys.argv[1]
output_file = sys.argv[2]
snippet_name = sys.argv[3]
style_ids = sys.argv[4:]

# Define namespace
ns = {
    'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
    'mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
    'w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
    'w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
    'w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex'
}

# Register namespaces for output
for prefix, uri in ns.items():
    ET.register_namespace(prefix, uri)

# Parse the styles.xml file
tree = ET.parse(styles_xml_path)
root = tree.getroot()

# Find all styles with matching styleIds (case-insensitive)
matching_styles = []
for style_id in style_ids:
    # Do case-insensitive search through all styles
    found = False
    for style_elem in root.findall('.//w:style', ns):
        actual_style_id = style_elem.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId')
        if actual_style_id and actual_style_id.lower() == style_id.lower():
            matching_styles.append(style_elem)
            print(f"Found: {actual_style_id} (matched '{style_id}')")
            found = True
            break
    if not found:
        print(f"Warning: Style ID not found: {style_id}")

if not matching_styles:
    print("Error: No matching styles found")
    sys.exit(1)

# Read the original source file to preserve exact formatting
with open(styles_xml_path, 'r', encoding='UTF-8') as source:
    source_content = source.read()

# Collect all extracted style texts first to detect namespaces
import re
extracted_styles = []
for style_elem in matching_styles:
    style_id = style_elem.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId')
    
    # Find the style element in the source text using regex
    # Include leading whitespace in the capture to preserve indentation
    pattern = rf'([ \t]*<w:style\s[^>]*?w:styleId="{style_id}"[^>]*?>.*?</w:style>)'
    match = re.search(pattern, source_content, re.DOTALL)
    
    if match:
        extracted_styles.append(match.group(1))

# Detect which namespaces are actually used in the extracted styles
combined_text = ''.join(extracted_styles)
used_namespaces = {'w': ns['w']}  # Always include w:

# Check for other namespace prefixes
if re.search(r'<(?:mc|w14|w15|w16se):', combined_text) or re.search(r'\s(?:mc|w14|w15|w16se):', combined_text):
    if 'mc:' in combined_text:
        used_namespaces['mc'] = ns['mc']
    if 'w14:' in combined_text:
        used_namespaces['w14'] = ns['w14']
    if 'w15:' in combined_text:
        used_namespaces['w15'] = ns['w15']
    if 'w16se:' in combined_text:
        used_namespaces['w16se'] = ns['w16se']
    if 'r:' in combined_text:
        used_namespaces['r'] = ns['r']

# Write snippet file with detected namespaces
with open(output_file, 'w', encoding='UTF-8') as f:
    f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
    
    # Build namespace declarations
    ns_declarations = ' '.join([f'xmlns:{prefix}="{uri}"' for prefix, uri in used_namespaces.items()])
    f.write(f'<snippet id="{snippet_name}" {ns_declarations}>\n')
    
    # Write each extracted style
    for style_text in extracted_styles:
        f.write(style_text)
        # Add newline if the style doesn't end with one
        if not style_text.endswith('\n'):
            f.write('\n')
    
    f.write('</snippet>\n')

print(f"\nSnippet created successfully with {len(matching_styles)} style(s)")
PYTHON_SCRIPT

if [ $? -eq 0 ]; then
    echo "✓ Snippet file created: $OUTPUT_FILE"
else
    echo "✗ Failed to create snippet file"
    exit 1
fi
