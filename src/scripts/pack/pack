#!/usr/bin/env bash
# OpenXML Pack Alias
# Usage: pack <source directory> [output file]
# If output file is not provided, it will be auto-generated in the out folder

set -euo pipefail

if [ $# -lt 1 ]; then
    echo "Usage: pack <source directory> [output file]"
    echo "Example: pack builds/jbc/workspace/jbcNormal/in"
    echo "Example: pack builds/jbc/templates/jbcMemo/in"
    echo "Example: pack builds/jbc/workspace/jbcSheet/in builds/jbc/workspace/jbcSheet/out/CustomSheet.xltx"
    exit 1
fi

# Get the script directory to find the project
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"

SOURCE_DIR="$1"

## Simplified packing: accept a folder (expanded or in/) and auto-generate an output file
## Behavior:
##  - If you pass the 'in' folder (e.g. builds/agency/category/template/in) it will pack that folder
##  - If you pass an expanded folder (e.g. builds/.../Template_expanded) it will pack that folder
##  - If no output is provided, the script will create <template>/out/<templateName>.<ext>
##    extension is chosen by detecting word/ or xl/ and whether vbaProject.bin exists

if [[ "$SOURCE_DIR" == /* ]]; then
    # Convert to project-relative path for downstream logic
    REL_SOURCE="${SOURCE_DIR#$PROJECT_ROOT/}"
else
    REL_SOURCE="$SOURCE_DIR"
fi

# Determine actual folder to pack and template root
if [ -d "$REL_SOURCE/in" ]; then
    # common case: user passed the template root and 'in' exists
    SOURCE_TO_PACK="$REL_SOURCE/in"
    TEMPLATE_DIR="$REL_SOURCE"
elif [ "$(basename "$REL_SOURCE")" == "in" ] && [ -d "$REL_SOURCE" ]; then
    SOURCE_TO_PACK="$REL_SOURCE"
    TEMPLATE_DIR="$(dirname "$REL_SOURCE")"
elif [ -d "$REL_SOURCE/word" ] || [ -d "$REL_SOURCE/xl" ]; then
    # user passed an expanded/template directory that contains word/ or xl/
    SOURCE_TO_PACK="$REL_SOURCE"
    TEMPLATE_DIR="$REL_SOURCE"
else
    # Fallback: if the argument is an absolute path we already stripped prefix, try original
    if [ -d "$1" ]; then
        # use original supplied path
        if [ -d "$1/in" ]; then
            SOURCE_TO_PACK="$1/in"
            TEMPLATE_DIR="$(dirname "$1/in")"
        else
            SOURCE_TO_PACK="$1"
            TEMPLATE_DIR="$1"
        fi
    else
        echo "Error: Cannot determine template folder to pack from: $1" >&2
        exit 1
    fi
fi

## Derive absolute template dir and output directory
if [[ "$TEMPLATE_DIR" == /* ]]; then
    ABS_TEMPLATE_DIR="$TEMPLATE_DIR"
else
    ABS_TEMPLATE_DIR="$PROJECT_ROOT/$TEMPLATE_DIR"
fi

TEMPLATE_NAME="$(basename "$ABS_TEMPLATE_DIR")"
# If the folder name ends with _expanded, strip that suffix for the output filename
TEMPLATE_NAME_CLEAN="${TEMPLATE_NAME%_expanded}"

# Choose out directory:
# - For expanded folders (ending with _expanded) place the out folder beside the expanded dir (parent/out)
# - Otherwise keep the out folder inside the template directory (templateDir/out)
if [[ "${TEMPLATE_NAME,,}" == *_expanded ]]; then
    TEMPLATE_PARENT_DIR="$(dirname "$ABS_TEMPLATE_DIR")"
    OUT_DIR="$TEMPLATE_PARENT_DIR/out"
else
    OUT_DIR="$ABS_TEMPLATE_DIR/out"
fi
mkdir -p "$OUT_DIR"

# Determine extension: prefer xl (.xltx/.xltm) if xl/ exists, otherwise word (.dotx/.dotm)
EXT="dotx"
if [ -d "$SOURCE_TO_PACK/xl" ]; then
    # excel
    if [ -f "$SOURCE_TO_PACK/xl/vbaProject.bin" ] || [ -f "$SOURCE_TO_PACK/vbaProject.bin" ]; then
        EXT="xltm"
    else
        EXT="xltx"
    fi
elif [ -d "$SOURCE_TO_PACK/word" ]; then
    # word
    if [ -f "$SOURCE_TO_PACK/word/vbaProject.bin" ] || [ -f "$SOURCE_TO_PACK/vbaProject.bin" ]; then
        EXT="dotm"
    else
        EXT="dotx"
    fi
fi

# Use provided output file if specified
if [ $# -gt 1 ]; then
    OUTPUT_FILE="$2"
    mkdir -p "$(dirname "$OUTPUT_FILE")"
else
    OUTPUT_FILE="$OUT_DIR/${TEMPLATE_NAME_CLEAN}.${EXT}"
    echo "Auto-generating: $OUTPUT_FILE"
fi

# Run the dotnet pack
dotnet run --project "$PROJECT_ROOT/src/OpenXmlApp/OpenXmlApp.csproj" -- pack "$SOURCE_TO_PACK" "$OUTPUT_FILE"
