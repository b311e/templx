#!/usr/bin/env python3
"""
style_import_map - import styles from partial snippets according to a mapping file

Usage: style_import_map <target-styles-xml> [--mapping docs/style-mapping.yml] [--dry-run] [--replace]

Naming: wrapper command is `style-import-map`; script filename is `style_import_map`.
"""
import argparse
import os
import re
import json
import shutil
import xml.etree.ElementTree as ET
# Preserve common Word namespaces so written XML uses `w:` etc.
ET.register_namespace('w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main')
ET.register_namespace('mc', 'http://schemas.openxmlformats.org/markup-compatibility/2006')
ET.register_namespace('r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships')

def parse_mapping_text(path):
    """Parse a simple mapping file that contains repeated blocks like:
    style-group: {default}
      partial: {Normal}
    Returns list of (group, partial) in the file order.
    """
    entries = []
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    i = 0
    while i < len(lines):
        m = re.match(r"^\s*style-group:\s*(?:\{([^}]+)\}|(.+))", lines[i])
        if m:
            group = (m.group(1) or m.group(2) or '').strip()
            # look ahead for partial line
            partial = None
            j = i + 1
            while j < len(lines) and (lines[j].strip() == '' or lines[j].startswith(' ')):
                pm = re.match(r"^\s*partial:\s*(?:\{([^}]+)\}|(.+))", lines[j])
                if pm:
                    partial = (pm.group(1) or pm.group(2) or '').strip()
                    break
                j += 1
            entries.append((group, partial))
            i = j
        else:
            i += 1
    return entries

def load_style_order(path):
    # minimal YAML parsing: find style-group section and preserve order of keys
    import yaml
    with open(path, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    # data expected to have 'style-group' mapping
    return data.get('style-group', {}) if isinstance(data, dict) else {}

def load_partials_manifests(repo_root):
    manifests = []
    candidates = [
        os.path.join(repo_root, 'builds', 'manifests', 'partials-manifest.json'),
        os.path.join(repo_root, 'core', 'manifests', 'partials-manifest.json')
    ]
    for p in candidates:
        if os.path.exists(p):
            try:
                with open(p, 'r', encoding='utf-8') as f:
                    js = json.load(f)
                    manifests.extend(js.get('snippets', []))
            except Exception:
                continue
    return manifests

def find_partial_snippet(manifests, template_name, style_group, preferred_agency=None, preferred_parent=None):
    # search for snippet whose id contains template_name and style_group (case-insensitive)
    tn = (template_name or '').lower()
    sg = (style_group or '').lower()
    # First try to find a best match that includes preferred agency or parent in path
    def path_matches_preference(path):
        if not path:
            return False
        p = path.replace('\\', '/').lower()
        if preferred_agency and f"/builds/{preferred_agency.lower()}/" in p:
            return True
        if preferred_parent and f"/{preferred_parent.lower()}/" in p:
            return True
        return False

    # strong match: contains template_name and style_group and preferred agency/parent
    for s in manifests:
        sid = (s.get('id') or '').lower()
        tags = [t.lower() for t in s.get('tags') or []]
        target = (s.get('target') or '').lower()
        path = s.get('path') or ''
        if tn and tn in sid and sg in sid and path_matches_preference(path) and ('styles' in tags or 'word:styles' in target or target == 'word:styles'):
            return path

    # next prefer preferred agency/parent with looser id matching
    for s in manifests:
        sid = (s.get('id') or '').lower()
        tags = [t.lower() for t in s.get('tags') or []]
        target = (s.get('target') or '').lower()
        path = s.get('path') or ''
        if path_matches_preference(path) and ('styles' in tags or 'word:styles' in target or target == 'word:styles'):
            if tn == '' or tn in sid:
                return path

    # fallback: original behavior
    for s in manifests:
        sid = (s.get('id') or '').lower()
        tags = [t.lower() for t in s.get('tags') or []]
        target = (s.get('target') or '').lower()
        if tn and tn in sid and sg in sid and ('styles' in tags or 'word:styles' in target or target == 'word:styles'):
            return s.get('path')
    # fallback: try matching just template_name
    for s in manifests:
        sid = (s.get('id') or '').lower()
        if tn and tn in sid and ('styles' in [t.lower() for t in s.get('tags') or []] or 'word:styles' in (s.get('target') or '').lower()):
            return s.get('path')
    return None

NS = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}

def extract_styles_from_snippet(snippet_path, repo_root):
    full = os.path.join(repo_root, snippet_path.replace('/', os.sep))
    if not os.path.exists(full):
        return []
    try:
        tree = ET.parse(full)
        root = tree.getroot()
    except Exception:
        return []
    styles = []
    for style in root.findall('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}style'):
        sid = style.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId')
        styles.append((sid, style))
    return styles

def main():
    parser = argparse.ArgumentParser(prog='style_import_map')
    parser.add_argument('target', help='target styles.xml to modify')
    # default mapping filename changed to `style-map.yml`; keep compatibility with `style-mapping.yml`
    parser.add_argument('--mapping', default='docs/style-map.yml')
    parser.add_argument('--styles-order', default=os.path.join('src','scripts','style','styles-order.yml'))
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--replace', action='store_true', help='Replace existing styles with same id')
    parser.add_argument('--backup', action='store_true', dest='backup', help='Create a .bak backup before writing (disabled by default)')
    args = parser.parse_args()

    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))

    # Auto-discover mapping file: if the provided mapping doesn't exist or
    # the user relied on the default, search upward from the target for
    # a `docs/style-map.yml` (preferred) or the legacy `docs/style-mapping.yml` next to the template
    # (e.g., builds/<agency>/<template>/docs/...)
    if not os.path.isabs(args.mapping):
        mapping_candidate = os.path.join(os.getcwd(), args.mapping)
    else:
        mapping_candidate = args.mapping

    if not os.path.exists(mapping_candidate):
        target_abs = os.path.abspath(args.target)
        cur = os.path.dirname(target_abs)
        found = None
        repo_root_abs = os.path.abspath(repo_root)
        while True:
            candidate1 = os.path.join(cur, 'docs', 'style-map.yml')
            candidate2 = os.path.join(cur, 'docs', 'style-mapping.yml')
            if os.path.exists(candidate1):
                found = candidate1
                break
            if os.path.exists(candidate2):
                found = candidate2
                break
            if os.path.abspath(cur) == repo_root_abs or cur == os.path.dirname(cur):
                break
            cur = os.path.dirname(cur)
        if found:
            args.mapping = found
        else:
            # leave args.mapping as-is; parse_mapping_text will raise a FileNotFoundError
            pass

    mapping_entries = parse_mapping_text(args.mapping)
    style_order = load_style_order(args.styles_order)
    manifests = load_partials_manifests(repo_root)

    # Build list of styles to import in order
    import_list = []  # tuples (styleId, element)

    # Infer preferred agency and parent template from the mapping file location and contents
    preferred_agency = None
    preferred_parent = None
    try:
        # mapping path may be absolute or relative; normalize
        mapping_abs = os.path.abspath(args.mapping)
        parts = mapping_abs.replace('\\', '/').split('/')
        # look for 'builds/<agency>' pattern
        if 'builds' in parts:
            bi = parts.index('builds')
            if bi + 1 < len(parts):
                preferred_agency = parts[bi + 1]
        # try to read 'parent' or 'template' keys from mapping file
        with open(args.mapping, 'r', encoding='utf-8') as mf:
            txt = mf.read()
            pm = re.search(r"^\s*parent:\s*(\S+)", txt, re.M)
            tm = re.search(r"^\s*template:\s*(\S+)", txt, re.M)
            if pm:
                preferred_parent = pm.group(1).strip()
            elif tm:
                preferred_parent = tm.group(1).strip()
    except Exception:
        pass

    # If mapping references a parent template like 'osaReport', derive agency 'osa' from builds/ folders
    try:
        builds_dir = os.path.join(repo_root, 'builds')
        if os.path.isdir(builds_dir) and preferred_parent:
            for entry in os.listdir(builds_dir):
                if entry in ('manifests', 'tmp'):
                    continue
                if preferred_parent.lower().startswith(entry.lower()):
                    preferred_agency = entry
                    break
    except Exception:
        pass

    for group, partial in mapping_entries:
        group_key = group
        # find style names for this group from style_order
        style_names = []
        if isinstance(style_order, dict):
            # style_order keys may include the group
            grp = style_order.get(group_key) or style_order.get(group_key.lower())
            if isinstance(grp, list):
                style_names = grp
        # find partial snippet path
        search_partial = partial
        if preferred_agency and partial:
            # prefer agency-prefixed template names (e.g., 'osa' + 'Normal' -> 'osaNormal')
            if not partial.lower().startswith(preferred_agency.lower()):
                search_partial = preferred_agency + partial
        snippet_path = find_partial_snippet(manifests, search_partial, group_key, preferred_agency=preferred_agency, preferred_parent=preferred_parent)
        if not snippet_path:
            print(f"Warning: no partial snippet found for partial='{partial}' group='{group_key}'")
            continue
        styles = extract_styles_from_snippet(snippet_path, repo_root)
        styles_dict = { (s[0] or '').lower(): s[1] for s in styles }
        for name in style_names:
            sid = name
            if sid is None:
                continue
            key = sid.lower()
            if key in styles_dict:
                import_list.append((sid, styles_dict[key], snippet_path))
            else:
                # not found in this snippet
                pass

    if args.dry_run:
        print('Dry run: will import the following styles in order:')
        for sid, elem, src in import_list:
            print(f"  {sid} <- {src}")
        return 0

    # modify target styles.xml
    if not os.path.exists(args.target):
        print('Target styles.xml not found:', args.target)
        return 2
    backup = args.target + '.bak'
    backup_created = False
    if args.backup:
        shutil.copyfile(args.target, backup)
        backup_created = True
    tree = ET.parse(args.target)
    root = tree.getroot()
    # ensure namespace
    for sid, elem, src in import_list:
        # check if exists
        found = None
        for existing in root.findall('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}style'):
            if (existing.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId') or '').lower() == (sid or '').lower():
                found = existing
                break
        if found is not None:
            if args.replace:
                parent = root
                parent.remove(found)
            else:
                continue
        # append element (imported element may belong to a different tree)
        root.append(elem)

    tree.write(args.target, encoding='utf-8', xml_declaration=True)
    # Always report the write; include backup info only if created.
    if backup_created:
        print('Wrote', args.target, '(backup at', backup + ')')
    else:
        print('Wrote', args.target)
    return 0

if __name__ == '__main__':
    raise SystemExit(main())
