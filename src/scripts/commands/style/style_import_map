#!/usr/bin/env python3
"""
style_import_map - import styles from partial snippets according to a mapping file

Usage: style_import_map <target-styles-xml> [--mapping docs/style-mapping.yml] [--dry-run] [--replace]

Naming: wrapper command is `style-import-map`; script filename is `style_import_map`.
"""
import argparse
import os
import re
import json
import shutil
import xml.etree.ElementTree as ET
import copy
# Preserve common Word namespaces so written XML uses `w:` etc.
ET.register_namespace('w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main')
ET.register_namespace('mc', 'http://schemas.openxmlformats.org/markup-compatibility/2006')
ET.register_namespace('r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships')
# Additional Word namespaces that may appear in mc:Ignorable — register so they can be emitted
ET.register_namespace('w14', 'http://schemas.microsoft.com/office/word/2010/wordml')
ET.register_namespace('w15', 'http://schemas.microsoft.com/office/word/2012/wordml')
ET.register_namespace('w16se', 'http://schemas.microsoft.com/office/word/2015/wordml/symex')
ET.register_namespace('w16cid', 'http://schemas.microsoft.com/office/word/2016/wordml/cid')
ET.register_namespace('w16', 'http://schemas.microsoft.com/office/word/2018/wordml')
ET.register_namespace('w16cex', 'http://schemas.microsoft.com/office/word/2015/wordml/cex')
ET.register_namespace('w16sdtdh', 'http://schemas.microsoft.com/office/word/2021/wordml/sdtdefhash')

def parse_mapping_text(path):
    """Parse a simple mapping file that contains repeated blocks like:
    style_group: {default}
      partial: {Normal}
    Returns list of (group, partial) in the file order.
    """
    entries = []
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    i = 0
    while i < len(lines):
        m = re.match(r"^\s*style_group:\s*(?:\{([^}]+)\}|(.+))", lines[i])
        if m:
            group = (m.group(1) or m.group(2) or '').strip()
            # look ahead for partial line
            partial = None
            j = i + 1
            while j < len(lines) and (lines[j].strip() == '' or lines[j].startswith(' ')):
                pm = re.match(r"^\s*partial:\s*(?:\{([^}]+)\}|(.+))", lines[j])
                if pm:
                    partial = (pm.group(1) or pm.group(2) or '').strip()
                    break
                j += 1
            entries.append((group, partial))
            i = j
        else:
            i += 1
    return entries

def load_style_order(path):
    # minimal YAML parsing: find style_group section and preserve order of keys
    import yaml
    with open(path, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    # data expected to have 'style_group' mapping
    return data.get('style_group', {}) if isinstance(data, dict) else {}

def load_partials_manifests(repo_root):
    manifests = []
    candidates = [
        os.path.join(repo_root, 'builds', 'manifests', 'partials-manifest.json'),
        os.path.join(repo_root, 'core', 'manifests', 'partials-manifest.json')
    ]
    for p in candidates:
        if os.path.exists(p):
            try:
                with open(p, 'r', encoding='utf-8') as f:
                    js = json.load(f)
                    manifests.extend(js.get('snippets', []))
            except Exception:
                continue
    return manifests

def find_partial_snippet(manifests, template_name, style_group, preferred_agency=None, preferred_parent=None):
    # search for snippet whose id contains template_name and style_group (case-insensitive)
    tn = (template_name or '').lower()
    sg = (style_group or '').lower()
    # First try to find a best match that includes preferred agency or parent in path
    def path_matches_preference(path):
        if not path:
            return False
        p = path.replace('\\', '/').lower()
        if preferred_agency and f"/builds/{preferred_agency.lower()}/" in p:
            return True
        if preferred_parent and f"/{preferred_parent.lower()}/" in p:
            return True
        return False

    # strong match: contains template_name and style_group and preferred agency/parent
    for s in manifests:
        sid = (s.get('id') or '').lower()
        tags = [t.lower() for t in s.get('tags') or []]
        target = (s.get('target') or '').lower()
        path = s.get('path') or ''
        if tn and tn in sid and sg in sid and path_matches_preference(path) and ('styles' in tags or 'word:styles' in target or target == 'word:styles'):
            return path

    # next prefer preferred agency/parent with looser id matching
    for s in manifests:
        sid = (s.get('id') or '').lower()
        tags = [t.lower() for t in s.get('tags') or []]
        target = (s.get('target') or '').lower()
        path = s.get('path') or ''
        if path_matches_preference(path) and ('styles' in tags or 'word:styles' in target or target == 'word:styles'):
            if tn == '' or tn in sid:
                return path

    # fallback: original behavior
    for s in manifests:
        sid = (s.get('id') or '').lower()
        tags = [t.lower() for t in s.get('tags') or []]
        target = (s.get('target') or '').lower()
        if tn and tn in sid and sg in sid and ('styles' in tags or 'word:styles' in target or target == 'word:styles'):
            return s.get('path')
    # fallback: try matching just template_name
    for s in manifests:
        sid = (s.get('id') or '').lower()
        if tn and tn in sid and ('styles' in [t.lower() for t in s.get('tags') or []] or 'word:styles' in (s.get('target') or '').lower()):
            return s.get('path')
    return None

NS = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}

def extract_styles_from_snippet(snippet_path, repo_root):
    full = os.path.join(repo_root, snippet_path.replace('/', os.sep))
    if not os.path.exists(full):
        return []
    try:
        tree = ET.parse(full)
        root = tree.getroot()
    except Exception:
        return []
    styles = []
    for style in root.findall('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}style'):
        sid = style.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId')
        # collect display name and aliases to allow matching by either styleId or name
        names = []
        if sid:
            names.append(sid)
        # w:name element (display name)
        name_el = style.find('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}name')
        if name_el is not None:
            name_val = name_el.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}val') or name_el.get('val')
            if name_val:
                names.append(name_val)
        # w:aliases element may contain comma-separated names
        aliases_el = style.find('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}aliases')
        if aliases_el is not None:
            alias_val = aliases_el.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}val') or aliases_el.get('val')
            if alias_val:
                for a in re.split(r"\s*,\s*", alias_val):
                    if a:
                        names.append(a)
        styles.append((sid, style, names))
    return styles

def main():
    parser = argparse.ArgumentParser(prog='style_import_map')
    parser.add_argument('target', help='target styles.xml to modify')
    # default mapping filename changed to `style-map.yml`; keep compatibility with `style-mapping.yml`
    parser.add_argument('--mapping', default='docs/style-map.yml')
    parser.add_argument('--styles-order', default=os.path.join('src','scripts','lib','schemas','style-map-schema.yml'))
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--replace', action='store_true', help='Replace existing styles with same id')
    parser.add_argument('--backup', action='store_true', dest='backup', help='Create a .bak backup before writing (disabled by default)')
    args = parser.parse_args()

    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))

    # Auto-discover mapping file: if the provided mapping doesn't exist or
    # the user relied on the default, search upward from the target for
    # a `docs/style-map.yml` (preferred) or the legacy `docs/style-mapping.yml` next to the template
    # (e.g., builds/<agency>/<template>/docs/...)
    if not os.path.isabs(args.mapping):
        mapping_candidate = os.path.join(os.getcwd(), args.mapping)
    else:
        mapping_candidate = args.mapping

    if not os.path.exists(mapping_candidate):
        target_abs = os.path.abspath(args.target)
        cur = os.path.dirname(target_abs)
        found = None
        repo_root_abs = os.path.abspath(repo_root)
        while True:
            candidate1 = os.path.join(cur, 'docs', 'style-map.yml')
            candidate2 = os.path.join(cur, 'docs', 'style-mapping.yml')
            if os.path.exists(candidate1):
                found = candidate1
                break
            if os.path.exists(candidate2):
                found = candidate2
                break
            if os.path.abspath(cur) == repo_root_abs or cur == os.path.dirname(cur):
                break
            cur = os.path.dirname(cur)
        if found:
            args.mapping = found
        else:
            # leave args.mapping as-is; parse_mapping_text will raise a FileNotFoundError
            pass

    mapping_entries = parse_mapping_text(args.mapping)
    style_order = load_style_order(args.styles_order)
    manifests = load_partials_manifests(repo_root)

    # Build list of styles to import in order
    import_list = []  # tuples (styleId, element)

    # Infer preferred agency and parent template from the mapping file location and contents
    preferred_agency = None
    preferred_parent = None
    try:
        # mapping path may be absolute or relative; normalize
        mapping_abs = os.path.abspath(args.mapping)
        parts = mapping_abs.replace('\\', '/').split('/')
        # look for 'builds/<agency>' pattern
        if 'builds' in parts:
            bi = parts.index('builds')
            if bi + 1 < len(parts):
                preferred_agency = parts[bi + 1]
        # try to read 'parent' or 'template' keys from mapping file
        with open(args.mapping, 'r', encoding='utf-8') as mf:
            txt = mf.read()
            pm = re.search(r"^\s*parent:\s*(\S+)", txt, re.M)
            tm = re.search(r"^\s*template:\s*(\S+)", txt, re.M)
            if pm:
                preferred_parent = pm.group(1).strip()
            elif tm:
                preferred_parent = tm.group(1).strip()
    except Exception:
        pass

    # If mapping references a parent template like 'osaReport', derive agency 'osa' from builds/ folders
    try:
        builds_dir = os.path.join(repo_root, 'builds')
        if os.path.isdir(builds_dir) and preferred_parent:
            for entry in os.listdir(builds_dir):
                if entry in ('manifests', 'tmp'):
                    continue
                if preferred_parent.lower().startswith(entry.lower()):
                    preferred_agency = entry
                    break
    except Exception:
        pass

    for group, partial in mapping_entries:
        group_key = group
        # find style names for this group from style_order
        style_names = []
        if isinstance(style_order, dict):
            # style_order keys may include the group
            grp = style_order.get(group_key) or style_order.get(group_key.lower())
            if isinstance(grp, list):
                style_names = grp
        # find partial snippet path
        search_partial = partial
        if preferred_agency and partial:
            # prefer agency-prefixed template names (e.g., 'osa' + 'Normal' -> 'osaNormal')
            if not partial.lower().startswith(preferred_agency.lower()):
                search_partial = preferred_agency + partial
        snippet_path = find_partial_snippet(manifests, search_partial, group_key, preferred_agency=preferred_agency, preferred_parent=preferred_parent)
        if not snippet_path:
            print(f"Warning: no partial snippet found for partial='{partial}' group='{group_key}'")
            continue
        styles = extract_styles_from_snippet(snippet_path, repo_root)
        # Build a lookup by multiple possible keys: styleId, display name, aliases
        styles_dict = {}
        for s in styles:
            sid = s[0]
            elem = s[1]
            names = s[2] if len(s) > 2 else []
            for key_name in names:
                if key_name:
                    styles_dict[key_name.lower()] = elem

        for name in style_names:
            sid = name
            if sid is None:
                continue
            key = sid.lower()
            if key in styles_dict:
                import_list.append((sid, styles_dict[key], snippet_path))
            else:
                # not found in this snippet
                pass

        # Also import any additional styles present in the snippet that were
        # not explicitly requested by styles-order. Preserve their snippet
        # order and avoid duplicates.
        existing = { (i[0] or '').lower() for i in import_list }
        for s in styles:
            s_sid = (s[0] or '')
            s_elem = s[1]
            if not s_sid:
                continue
            if s_sid.lower() in existing:
                continue
            import_list.append((s_sid, s_elem, snippet_path))
            existing.add(s_sid.lower())

    if args.dry_run:
        print('Dry run: will import the following styles in order:')
        for sid, elem, src in import_list:
            print(f"  {sid} <- {src}")
        return 0

    # modify target styles.xml
    if not os.path.exists(args.target):
        print('Target styles.xml not found:', args.target)
        return 2
    backup = args.target + '.bak'
    backup_created = False
    if args.backup:
        shutil.copyfile(args.target, backup)
        backup_created = True
    tree = ET.parse(args.target)
    root = tree.getroot()
    # If the original styles part declares `mc:Ignorable`, ensure the matching
    # `xmlns:prefix` attributes are present for those prefixes so Word accepts
    # the `mc:Ignorable` list. If no ignorable is present, fall back to adding
    # common Word prefixes so output remains compatible with recent Word features.
    mc_ignorable_attr = '{http://schemas.openxmlformats.org/markup-compatibility/2006}Ignorable'
    ignorable_val = root.get(mc_ignorable_attr)
    known_ns = {
        'w14': 'http://schemas.microsoft.com/office/word/2010/wordml',
        'w15': 'http://schemas.microsoft.com/office/word/2012/wordml',
        'w16se': 'http://schemas.microsoft.com/office/word/2015/wordml/symex',
        'w16cid': 'http://schemas.microsoft.com/office/word/2016/wordml/cid',
        'w16': 'http://schemas.microsoft.com/office/word/2018/wordml',
        'w16cex': 'http://schemas.microsoft.com/office/word/2015/wordml/cex',
        'w16sdtdh': 'http://schemas.microsoft.com/office/word/2021/wordml/sdtdefhash'
    }
    # Note: do not set xmlns attributes via ElementTree here — some parsers
    # produce transient nsN bindings. We'll inject missing xmlns:prefix
    # declarations into the serialized start-tag later as a safe fallback.
    # ensure namespace
    for sid, elem, src in import_list:
        # check if exists
        found = None
        for existing in root.findall('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}style'):
            if (existing.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}styleId') or '').lower() == (sid or '').lower():
                found = existing
                break
        if found is not None:
            # Always replace existing styles so partials override target styles
            removed = False
            for parent in root.iter():
                for child in list(parent):
                    if child is found:
                        parent.remove(child)
                        removed = True
                        break
                if removed:
                    break
            if not removed:
                try:
                    root.remove(found)
                except Exception:
                    pass
        # append a deep-copy of the element so we don't move it out of the
        # source snippet tree (prevents subtle reuse/mutation bugs)
        root.append(copy.deepcopy(elem))

    # ElementTree sometimes omits xmlns declarations for prefixes that only
    # appear in attribute values (e.g., mc:Ignorable). As a robust fallback
    # ensure the serialized root start-tag contains the xmlns:prefix entries
    # for any prefixes we intend to declare.
    # Determine prefixes to ensure (from ignorable or known_ns)
    if ignorable_val:
        prefixes_to_ensure = [p for p in re.split(r'\s+', ignorable_val.strip()) if p]
    else:
        prefixes_to_ensure = list(known_ns.keys())

    # Serialize root to string. ElementTree may add transient nsN artifacts
    # when manipulating xmlns attributes; perform a safe textual cleanup and
    # inject only the missing xmlns:prefix declarations into the opening
    # <w:styles> tag.
    raw = ET.tostring(root, encoding='utf-8', method='xml').decode('utf-8')

    # Remove any accidental nsN xmlns declarations and any nsN:pref attributes
    raw = re.sub(r"\sxmlns:ns\d+=[\"]http://www.w3.org/2000/xmlns/[\"]", '', raw)
    raw = re.sub(r"\sns\d+:[A-Za-z0-9_:-]+=\"[^\"]*\"", '', raw)

    m = re.search(r'(<w:styles\b[^>]*>)', raw)
    if m:
        full_tag = m.group(1)  # includes trailing '>'
        inner = full_tag[:-1]  # drop final '>' for manipulation
        additions = ''
        for p in prefixes_to_ensure:
            if f'xmlns:{p}="' not in inner:
                uri = known_ns.get(p)
                if uri:
                    additions += f' xmlns:{p}="{uri}"'
        if additions:
            new_tag = inner + additions + '>'
            raw = raw[:m.start(1)] + new_tag + raw[m.end(1):]

    with open(args.target, 'wb') as out:
        out.write(b"<?xml version='1.0' encoding='utf-8'?>\n")
        out.write(raw.encode('utf-8'))
    # Always report the write; include backup info only if created.
    if backup_created:
        print('Wrote', args.target, '(backup at', backup + ')')
    else:
        print('Wrote', args.target)
    return 0

if __name__ == '__main__':
    raise SystemExit(main())
